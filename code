!pip install akshare pandas numpy pytz
import akshare as ak
import pandas as pd
import numpy as np
from datetime import datetime, time
import pytz


# =========================================
# 0) ä½ åªéœ€è¦æ”¹è¿™é‡Œ
# =========================================
SYMBOL = "159915"  # Aè‚¡ETFä»£ç ï¼š159915 / 510300 / 512480 ...
W = 0.50           # å½“å‰ä»“ä½ï¼ˆ0~1ï¼‰
# =========================================


# =========================================
# 1) åŒ—äº¬æ—¶é—´ä¸äº¤æ˜“æ—¶æ®µåˆ¤åˆ«ï¼ˆETFåŒAè‚¡ï¼‰
# =========================================
def beijing_now():
    tz = pytz.timezone("Asia/Shanghai")
    return datetime.now(tz)

def beijing_now_str():
    return beijing_now().strftime("%Y-%m-%d %H:%M:%S")

def is_intraday_cn():
    now = beijing_now().time()
    morning = time(9, 30) <= now <= time(11, 30)
    afternoon = time(13, 0) <= now <= time(15, 0)
    return morning or afternoon

MODE = "ç›˜ä¸­" if is_intraday_cn() else "æ”¶ç›˜å"


# =========================================
# 2) æ•°æ®è·å–ï¼šAè‚¡ETFä¼˜å…ˆç”¨ fund_etf_hist_em
# =========================================
def get_etf_daily(symbol: str, lookback_days: int = 260) -> pd.DataFrame:
    """
    è¿”å›åˆ—ï¼šdate, open, high, low, close, volume
    """
    try:
        df = ak.fund_etf_hist_em(symbol=symbol, period="daily", adjust="qfq")
        df = df.rename(columns={
            "æ—¥æœŸ": "date",
            "å¼€ç›˜": "open",
            "æœ€é«˜": "high",
            "æœ€ä½": "low",
            "æ”¶ç›˜": "close",
            "æˆäº¤é‡": "volume",
        })
        df = df[["date", "open", "high", "low", "close", "volume"]]
    except Exception:
        df = ak.stock_zh_a_hist(symbol=symbol, period="daily", adjust="qfq")
        df = df.rename(columns={
            "æ—¥æœŸ": "date",
            "å¼€ç›˜": "open",
            "æœ€é«˜": "high",
            "æœ€ä½": "low",
            "æ”¶ç›˜": "close",
            "æˆäº¤é‡": "volume",
        })
        df = df[["date", "open", "high", "low", "close", "volume"]]

    df["date"] = pd.to_datetime(df["date"])
    df = df.sort_values("date").reset_index(drop=True)
    return df.tail(lookback_days).reset_index(drop=True)


def get_etf_realtime_last(symbol: str) -> float | None:
    """
    ç›˜ä¸­è·å–ETFå®æ—¶æœ€æ–°ä»·ã€‚æ‹¿ä¸åˆ°å°±è¿”å›Noneã€‚
    """
    try:
        spot = ak.fund_etf_spot_em()
        row = spot[spot["ä»£ç "].astype(str) == str(symbol)]
        if len(row) == 0:
            return None
        # å¸¸è§å­—æ®µï¼šæœ€æ–°ä»·
        return float(row["æœ€æ–°ä»·"].iloc[0])
    except Exception:
        return None


df = get_etf_daily(SYMBOL)
if len(df) < 80:
    raise ValueError("æ•°æ®ä¸è¶³ï¼šè¯·ç¡®è®¤ETFä»£ç æˆ–æ‰©å¤§å†å²åŒºé—´ã€‚")


# =========================================
# 3) æŒ‡æ ‡å‡½æ•°ï¼ˆå·²åšç¨³å®šæ€§å…œåº•ï¼‰
# =========================================
def vwap_proxy(df_: pd.DataFrame, n: int = 20) -> float:
    x = df_.tail(n)
    typical = (x["high"] + x["low"] + x["close"]) / 3.0
    vol = x["volume"].astype(float)
    s = vol.sum()
    if s <= 0:
        return float("nan")
    return float((typical * vol).sum() / s)

def atr(df_: pd.DataFrame, n: int = 10) -> float:
    prev_close = df_["close"].shift(1)
    tr = pd.concat([
        (df_["high"] - df_["low"]),
        (df_["high"] - prev_close).abs(),
        (df_["low"] - prev_close).abs(),
    ], axis=1).max(axis=1)
    return float(tr.rolling(n).mean().iloc[-1])

def max_drawdown(close: pd.Series, window: int = 10) -> float:
    s = close.tail(window)
    peak = s.cummax()
    dd = (s / peak - 1.0).min()
    return float(abs(dd))

def price_density_zone(df_: pd.DataFrame, lookback: int = 60, bins: int = 60, mass: float = 0.60):
    """
    ETFï¼šç”¨æ›´é•¿ lookback + æ›´å¤§ massï¼Œæ›´ç¨³åˆ»ç”»ç»“æ„åŒº
    è¿”å› (zone_low_struct, P_struct)
    """
    x = df_.tail(lookback)
    price = ((x["high"] + x["low"] + x["close"]) / 3.0).values
    weight = x["volume"].values.astype(float)

    pmin, pmax = float(price.min()), float(price.max())
    if pmax <= pmin:
        return pmin, pmax

    hist, edges = np.histogram(price, bins=bins, range=(pmin, pmax), weights=weight)
    total = hist.sum()
    if total <= 0:
        return pmin, pmax

    target = total * mass
    best = None
    for i in range(len(hist)):
        s = 0.0
        for j in range(i, len(hist)):
            s += hist[j]
            if s >= target:
                cand = (j - i, -s, i, j)
                if best is None or cand < best:
                    best = cand
                break

    if best is None:
        k = int(np.argmax(hist))
        return float(edges[k]), float(edges[k + 1])

    _, _, li, rj = best
    return float(edges[li]), float(edges[rj + 1])

def short_zone(df_: pd.DataFrame, n: int = 5):
    x = df_.tail(n)
    return float(x["low"].min()), float(x["high"].max())

def slope_pct(series: pd.Series) -> float:
    """
    ç”¨â€œç™¾åˆ†æ¯”åºåˆ—â€çš„æ–œç‡ï¼Œæ›´ç¨³å®šï¼ˆé¿å…ä»·æ ¼å°ºåº¦å½±å“ï¼‰
    """
    s = series.dropna()
    if len(s) < 6:
        return 0.0
    pct = s.pct_change().dropna()
    if len(pct) < 5:
        return 0.0
    x = np.arange(len(pct))
    k = np.polyfit(x, pct.values, 1)[0]
    return float(k)

def amp(series: pd.Series) -> float:
    s = series.dropna()
    if len(s) == 0:
        return 0.0
    return float((s.max() - s.min()) / s.mean())


# =========================================
# 4) æ ¸å¿ƒå˜é‡ï¼ˆC / P_struct / P_short / Base_P / Rï¼‰
# =========================================
# last é»˜è®¤ç”¨æ—¥çº¿æ”¶ç›˜
last = float(df["close"].iloc[-1])

# ç›˜ä¸­åˆ™ç”¨å®æ—¶æœ€æ–°ä»·è¦†ç›–ï¼ˆæ›´è´´ç›˜é¢ï¼‰
if MODE == "ç›˜ä¸­":
    rt = get_etf_realtime_last(SYMBOL)
    if rt is not None and np.isfinite(rt):
        last = float(rt)

C = vwap_proxy(df, 20)

zone_low_struct, P_struct = price_density_zone(df, lookback=60, bins=60, mass=0.60)
short_low, P_short = short_zone(df, n=5)

Base_P = max(P_struct, P_short)

ATR10 = atr(df, 10)
R10 = max_drawdown(df["close"], 10)


# =========================================
# 5) C_amp / P_amp / AR / SG / Corrï¼ˆç»“æ„è¾…åŠ©ï¼‰
# =========================================
typical = (df["high"] + df["low"] + df["close"]) / 3.0
vwap_series = (typical * df["volume"]).rolling(20).sum() / df["volume"].rolling(20).sum()
p_short_series = df["high"].rolling(5).max()

C_amp = amp(vwap_series.tail(15))
P_amp = amp(p_short_series.tail(15))
AR_amp = C_amp / (P_amp + 1e-6)  # å‘½åæ˜ç¡®ï¼šæŒ¯å¹…æ¯”

SG = slope_pct(vwap_series.tail(20)) - slope_pct(p_short_series.tail(20))

Corr = pd.concat([vwap_series, p_short_series], axis=1).corr().iloc[0, 1]
Corr = float(Corr) if pd.notna(Corr) else 0.0


# =========================================
# 6) P_upgrade_level & NextP_band
# =========================================
def p_upgrade_level(C_amp, P_amp, SG, Corr):
    # ETFï¼šæ›´çœ‹é‡ç»“æ„åŒæ­¥ä¸ç¨³å®š
    if SG > 0 and Corr > 0.35 and C_amp <= P_amp:
        return "é«˜"
    if Corr > 0.15:
        return "ä¸­"
    return "ä½"

upgrade = p_upgrade_level(C_amp, P_amp, SG, Corr)
k_map = {"ä½": 0.6, "ä¸­": 1.0, "é«˜": 1.4}
k = k_map[upgrade]

NextP_low = Base_P
NextP_high = Base_P + k * ATR10
NextP_band = (round(NextP_low, 3), round(NextP_high, 3))

# C_opt_scoreï¼šæ˜¯å¦å€¼å¾—ç»§ç»­â€œç£¨C/åŠ¨ä»“â€
mid_next = (NextP_low + NextP_high) / 2
C_opt_score = ((mid_next - C) / C) - R10 * (1 + W)


# =========================================
# 7) ç›˜ä¸­ä¸‰è‰²ç¯ / ç›˜å NextAction
# =========================================
def intraday_light(last, zone_low, base_p, atr10):
    if last < zone_low:
        return "ğŸ”´ çº¢ç¯ï¼šè·Œç ´ç»“æ„æ”¯æ’‘ï¼Œä¼˜å…ˆé£æ§/å‡ä»“"
    if last >= base_p - 0.15 * atr10:
        return "ğŸŸ¡ é»„ç¯ï¼šæ¥è¿‘å‹åŠ›ä½Base_Pï¼Œä»…è§‚å¯Ÿæ˜¯å¦çªç ´"
    return "ğŸŸ¢ ç»¿ç¯ï¼šç»“æ„ç¨³å®šï¼Œç¦æ­¢æ“ä½œï¼ˆä¸åšTï¼‰"

def next_action(last, C, base_p, zone_low, upgrade, score, r10, atr10):
    if last < zone_low:
        return "ç»“æ„ç ´åï¼šåœæ­¢æ“ä½œï¼Œä¼˜å…ˆé£æ§/è€ƒè™‘é™ä»“"
    if r10 > 0.08:
        return "é£é™©æŠ¬å‡ï¼šä»¥é˜²å®ˆä¸ºä¸»ï¼Œå‡å°‘æš´éœ²"
    if upgrade == "é«˜":
        if last >= base_p:
            return "ç»“æ„å‡çº§ç¡®è®¤ï¼šå‡å°‘/åœæ­¢Tï¼ŒæŒä»“ç­‰å¾…è¶‹åŠ¿æ®µ"
        return "å‡çº§æ¡ä»¶æˆç†Ÿï¼šä¸æŠ˜è…¾ï¼Œè€å¿ƒç­‰å¾…ç¡®è®¤"
    if upgrade == "ä¸­":
        if score > 0 and last <= base_p - 0.5 * atr10:
            return "ç»“æ„å°šå¯ï¼šä»…åœ¨å›è¸©æ—¶å°å¹…ä¼˜åŒ–Cï¼ˆè½»ä»“ï¼‰"
        return "ç»“æ„æ”¹å–„ï¼šå‡å°‘Tï¼Œç­‰å¾…çªç ´ç¡®è®¤"
    # upgradeä½
    if score < -0.02:
        return "æ€§ä»·æ¯”åä½ï¼šä¸å»ºè®®åŠ ä»“ï¼Œå¿…è¦æ—¶é€æ­¥é™ä½ä»“ä½"
    return "è§‚æœ›ï¼šä¿æŒä»“ä½ï¼Œç­‰å¾…ç»“æ„æ˜æœ—"


# =========================================
# 8) è¾“å‡º
# =========================================
print("\n==============================")
print("ğŸ“Š Aè‚¡ETF Model Bï¼ˆæœ€ç»ˆç‰ˆï¼‰")
print("==============================")
print("å¸‚åœºç±»å‹: Aè‚¡ETF")
print(f"åŒ—äº¬æ—¶é—´: {beijing_now_str()}")
print(f"å½“å‰æ¨¡å¼: {MODE}")
print(f"ETFä»£ç : {SYMBOL}")
print("------------------------------")

print(f"last: {last:.3f}")
print(f"C: {C:.3f}")
print(f"P_struct: {P_struct:.3f}")
print(f"P_short: {P_short:.3f}")
print(f"Base_P: {Base_P:.3f}")
print(f"zone_low_struct: {zone_low_struct:.3f}")
print(f"short_low: {short_low:.3f}")
print(f"C_amp: {C_amp:.4f}")
print(f"P_amp: {P_amp:.4f}")
print(f"AR_amp(Camp/Pamp): {AR_amp:.3f}")
print(f"SG(pct_slope_diff): {SG:.6f}")
print(f"Corr(C,P): {Corr:.3f}")
print(f"ATR10: {ATR10:.3f}")
print(f"R10: {R10:.4f}")
print("------------------------------")

if MODE == "ç›˜ä¸­":
    print("ğŸš¦ ç›˜ä¸­ä¸‰è‰²ç¯:", intraday_light(last, zone_low_struct, Base_P, ATR10))
else:
    print(f"P_upgrade_level: {upgrade}")
    print(f"NextP_band: {NextP_band}")
    print(f"C_opt_score: {C_opt_score:.4f}")
    print("ğŸ“Œ æ¥ä¸‹æ¥å»ºè®®:", next_action(last, C, Base_P, zone_low_struct, upgrade, C_opt_score, R10, ATR10))

