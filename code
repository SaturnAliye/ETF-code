!pip install akshare pandas numpy pytz
import akshare as ak
import pandas as pd
import numpy as np
from datetime import datetime, time
import pytz

# =========================================
# 0) ä½ åªéœ€è¦æ”¹è¿™é‡Œ
# =========================================
SYMBOL = "159915"  # Aè‚¡ETFä»£ç ï¼Œå¦‚ 159915 / 510300 / 512480 ç­‰
W = 0.50           # å½“å‰ä»“ä½ï¼ˆ0~1ï¼‰
# =========================================

# =========================================
# 1) åŒ—äº¬æ—¶é—´ä¸äº¤æ˜“æ—¶æ®µåˆ¤åˆ«ï¼ˆETFåŒAè‚¡ï¼‰
# =========================================
def beijing_now_str():
    tz = pytz.timezone("Asia/Shanghai")
    return datetime.now(tz).strftime("%Y-%m-%d %H:%M:%S")

def is_intraday_cn():
    tz = pytz.timezone("Asia/Shanghai")
    now = datetime.now(tz).time()
    morning = time(9, 30) <= now <= time(11, 30)
    afternoon = time(13, 0) <= now <= time(15, 0)
    return morning or afternoon

MODE = "ç›˜ä¸­" if is_intraday_cn() else "æ”¶ç›˜å"

# =========================================
# 2) æ•°æ®è·å–ï¼šAè‚¡ETFä¼˜å…ˆç”¨ fund_etf_hist_em
# =========================================
def get_etf_daily(symbol: str, lookback_days: int = 260) -> pd.DataFrame:
    """
    è¿”å›åˆ—ï¼šdate, open, high, low, close, volume
    """
    try:
        df = ak.fund_etf_hist_em(symbol=symbol, period="daily", adjust="qfq")
        # å¸¸è§åˆ—åï¼šæ—¥æœŸã€å¼€ç›˜ã€æ”¶ç›˜ã€æœ€é«˜ã€æœ€ä½ã€æˆäº¤é‡
        df = df.rename(columns={
            "æ—¥æœŸ": "date",
            "å¼€ç›˜": "open",
            "æœ€é«˜": "high",
            "æœ€ä½": "low",
            "æ”¶ç›˜": "close",
            "æˆäº¤é‡": "volume",
        })
        df = df[["date", "open", "high", "low", "close", "volume"]]
    except Exception:
        # å…œåº•ï¼šéƒ¨åˆ†ä»£ç å¯èƒ½èµ° stock_zh_a_hist
        df = ak.stock_zh_a_hist(symbol=symbol, period="daily", adjust="qfq")
        df = df.rename(columns={
            "æ—¥æœŸ": "date",
            "å¼€ç›˜": "open",
            "æœ€é«˜": "high",
            "æœ€ä½": "low",
            "æ”¶ç›˜": "close",
            "æˆäº¤é‡": "volume",
        })
        df = df[["date", "open", "high", "low", "close", "volume"]]

    df["date"] = pd.to_datetime(df["date"])
    df = df.sort_values("date").reset_index(drop=True)

    # åªå–æœ€è¿‘ lookback_days ä¸ªäº¤æ˜“æ—¥ï¼ˆè¿‘ä¼¼ï¼‰
    return df.tail(lookback_days).reset_index(drop=True)

df = get_etf_daily(SYMBOL)

if len(df) < 80:
    raise ValueError("æ•°æ®ä¸è¶³ï¼Œå»ºè®®æ¢æ›´ä¹…çš„åŒºé—´æˆ–ç¡®è®¤ETFä»£ç æ˜¯å¦æ­£ç¡®ã€‚")

# =========================================
# 3) æŒ‡æ ‡å‡½æ•°
# =========================================
def vwap_proxy(df_: pd.DataFrame, n: int = 20) -> float:
    x = df_.tail(n)
    typical = (x["high"] + x["low"] + x["close"]) / 3.0
    return float((typical * x["volume"]).sum() / x["volume"].sum())

def atr(df_: pd.DataFrame, n: int = 10) -> float:
    prev_close = df_["close"].shift(1)
    tr = pd.concat([
        (df_["high"] - df_["low"]),
        (df_["high"] - prev_close).abs(),
        (df_["low"] - prev_close).abs(),
    ], axis=1).max(axis=1)
    return float(tr.rolling(n).mean().iloc[-1])

def max_drawdown(close: pd.Series, window: int = 10) -> float:
    s = close.tail(window)
    peak = s.cummax()
    dd = (s / peak - 1.0).min()
    return float(abs(dd))

def price_density_zone(df_: pd.DataFrame, lookback: int = 60, bins: int = 60, mass: float = 0.60):
    """
    ETFå»ºè®®ç”¨æ›´é•¿ lookback + æ›´å¤§ massï¼Œæ›´ç¨³åœ°åˆ»ç”»ç»“æ„åŒº
    è¿”å› (zone_low, zone_high=P_struct)
    """
    x = df_.tail(lookback)
    price = ((x["high"] + x["low"] + x["close"]) / 3.0).values
    weight = x["volume"].values.astype(float)

    pmin, pmax = float(price.min()), float(price.max())
    if pmax <= pmin:
        return pmin, pmax

    hist, edges = np.histogram(price, bins=bins, range=(pmin, pmax), weights=weight)
    total = hist.sum()
    if total <= 0:
        return pmin, pmax

    target = total * mass

    best = None  # (width, -sum, li, rj)
    for i in range(len(hist)):
        s = 0.0
        for j in range(i, len(hist)):
            s += hist[j]
            if s >= target:
                cand = (j - i, -s, i, j)
                if best is None or cand < best:
                    best = cand
                break

    if best is None:
        k = int(np.argmax(hist))
        return float(edges[k]), float(edges[k + 1])

    _, _, li, rj = best
    return float(edges[li]), float(edges[rj + 1])

def short_zone(df_: pd.DataFrame, n: int = 5):
    x = df_.tail(n)
    return float(x["low"].min()), float(x["high"].max())

def slope(series: pd.Series) -> float:
    s = series.dropna().values
    if len(s) < 6:
        return 0.0
    x = np.arange(len(s))
    # ç®€å•çº¿æ€§å›å½’æ–œç‡
    k = np.polyfit(x, s, 1)[0]
    return float(k)

def amp(series: pd.Series) -> float:
    s = series.dropna()
    if len(s) == 0:
        return 0.0
    return float((s.max() - s.min()) / s.mean())

# =========================================
# 4) è®¡ç®—æ ¸å¿ƒå˜é‡ï¼ˆC / P_struct / P_short / Base_P / Rï¼‰
# =========================================
last = float(df["close"].iloc[-1])

C = vwap_proxy(df, 20)

# ç»“æ„Pï¼ˆETFæ›´ç¨³å‚æ•°ï¼‰
zone_low_struct, P_struct = price_density_zone(df, lookback=60, bins=60, mass=0.60)

# çŸ­æœŸPï¼ˆç›˜é¢å‹åŠ›ï¼‰
short_low, P_short = short_zone(df, n=5)

Base_P = max(P_struct, P_short)

ATR10 = atr(df, 10)
R10 = max_drawdown(df["close"], 10)

# =========================================
# 5) C_amp / P_amp / AR / SG / Corrï¼ˆç»“æ„è¾…åŠ©ï¼‰
# =========================================
# Cåºåˆ—ï¼šrolling vwapï¼ˆä¸ºäº†é€Ÿåº¦ï¼Œç”¨è¿‘ä¼¼ï¼šæ»šåŠ¨20æ—¥vwapï¼‰
typical = (df["high"] + df["low"] + df["close"]) / 3.0
vwap_series = (typical * df["volume"]).rolling(20).sum() / df["volume"].rolling(20).sum()

# Påºåˆ—ï¼šç”¨çŸ­æœŸPåºåˆ—è¿‘ä¼¼ï¼ˆè®¡ç®—æˆæœ¬ä½ï¼‰
p_short_series = df["high"].rolling(5).max()

C_amp = amp(vwap_series.tail(15))
P_amp = amp(p_short_series.tail(15))
AR = C_amp / (P_amp + 1e-6)

SG = slope(vwap_series.tail(15)) - slope(p_short_series.tail(15))

Corr = float(pd.concat([vwap_series, p_short_series], axis=1).corr().iloc[0, 1])

# =========================================
# 6) P_upgrade_level & NextP_bandï¼ˆæ›´è´´ETFï¼‰
# =========================================
def p_upgrade_level(C_amp, P_amp, SG, Corr):
    # ETFæ›´ç¨³ï¼šç›¸å…³æ€§æ›´é‡è¦
    if SG > 0 and Corr > 0.35 and C_amp <= P_amp:
        return "é«˜"
    if Corr > 0.15:
        return "ä¸­"
    return "ä½"

upgrade = p_upgrade_level(C_amp, P_amp, SG, Corr)
k_map = {"ä½": 0.6, "ä¸­": 1.0, "é«˜": 1.4}
k = k_map[upgrade]

NextP_low = Base_P
NextP_high = Base_P + k * ATR10
NextP_band = (round(NextP_low, 3), round(NextP_high, 3))

# C_opt_scoreï¼šæ˜¯å¦å€¼å¾—ç»§ç»­â€œç£¨C/åŠ¨ä»“â€
C_opt_score = ( ( (NextP_low + NextP_high)/2 - C ) / C ) - R10 * (1 + W)

# =========================================
# 7) ç›˜ä¸­ä¸‰è‰²ç¯ / ç›˜å NextAction
# =========================================
def intraday_light(last, zone_low, base_p, atr10):
    # ETFç›˜ä¸­æ›´å»ºè®®å°‘åŠ¨ï¼šåªç»™â€œé£æ§/è§‚å¯Ÿ/ä¸åŠ¨â€
    if last < zone_low:
        return "ğŸ”´ çº¢ç¯ï¼šè·Œç ´ç»“æ„æ”¯æ’‘ï¼Œä¼˜å…ˆé£æ§/å‡ä»“"
    if last >= base_p - 0.15 * atr10:
        return "ğŸŸ¡ é»„ç¯ï¼šæ¥è¿‘å‹åŠ›ä½Base_Pï¼Œä»…è§‚å¯Ÿæ˜¯å¦çªç ´"
    return "ğŸŸ¢ ç»¿ç¯ï¼šç»“æ„ç¨³å®šï¼Œç¦æ­¢æ“ä½œï¼ˆä¸åšTï¼‰"

def next_action(last, C, base_p, zone_low, upgrade, score, r10, atr10):
    if last < zone_low:
        return "ç»“æ„ç ´åï¼šåœæ­¢æ“ä½œï¼Œä¼˜å…ˆé£æ§/è€ƒè™‘é™ä»“"
    if r10 > 0.08:
        return "é£é™©æŠ¬å‡ï¼šä»¥é˜²å®ˆä¸ºä¸»ï¼Œå‡å°‘æš´éœ²"
    if upgrade == "é«˜":
        if last >= base_p:
            return "ç»“æ„å‡çº§ç¡®è®¤ï¼šå‡å°‘/åœæ­¢Tï¼ŒæŒä»“ç­‰å¾…è¶‹åŠ¿æ®µ"
        return "å‡çº§æ¡ä»¶æˆç†Ÿï¼šä¸æŠ˜è…¾ï¼Œè€å¿ƒç­‰å¾…ç¡®è®¤"
    if upgrade == "ä¸­":
        if score > 0 and last <= base_p - 0.5 * atr10:
            return "ç»“æ„å°šå¯ï¼šä»…åœ¨å›è¸©æ—¶å°å¹…ä¼˜åŒ–Cï¼ˆè½»ä»“ï¼‰"
        return "ç»“æ„æ”¹å–„ï¼šå‡å°‘Tï¼Œç­‰å¾…çªç ´ç¡®è®¤"
    # upgradeä½
    if score < -0.02:
        return "æ€§ä»·æ¯”åä½ï¼šä¸å»ºè®®åŠ ä»“ï¼Œå¿…è¦æ—¶é€æ­¥é™ä½ä»“ä½"
    return "è§‚æœ›ï¼šä¿æŒä»“ä½ï¼Œç­‰å¾…ç»“æ„æ˜æœ—"

# =========================================
# 8) è¾“å‡º
# =========================================
print("\n==============================")
print("ğŸ“Š Aè‚¡ETF Model B å†³ç­–é¢æ¿")
print("==============================")
print(f"å¸‚åœºç±»å‹: Aè‚¡ETF")
print(f"åŒ—äº¬æ—¶é—´: {beijing_now_str()}")
print(f"å½“å‰æ¨¡å¼: {MODE}")
print(f"ETFä»£ç : {SYMBOL}")
print("------------------------------")

print(f"last: {last:.3f}")
print(f"C: {C:.3f}")
print(f"P_struct: {P_struct:.3f}")
print(f"P_short: {P_short:.3f}")
print(f"Base_P: {Base_P:.3f}")
print(f"zone_low_struct: {zone_low_struct:.3f}")
print(f"short_low: {short_low:.3f}")
print(f"C_amp: {C_amp:.4f}")
print(f"P_amp: {P_amp:.4f}")
print(f"AR(Camp/Pamp): {AR:.3f}")
print(f"SG(Cslope-Pslope): {SG:.4f}")
print(f"Corr(C,P): {Corr:.3f}")
print(f"ATR10: {ATR10:.3f}")
print(f"R10: {R10:.4f}")
print("------------------------------")

if MODE == "ç›˜ä¸­":
    print("ğŸš¦ ç›˜ä¸­ä¸‰è‰²ç¯:", intraday_light(last, zone_low_struct, Base_P, ATR10))
else:
    print(f"P_upgrade_level: {upgrade}")
    print(f"NextP_band: {NextP_band}")
    print(f"C_opt_score: {C_opt_score:.4f}")
    print("ğŸ“Œ æ¥ä¸‹æ¥å»ºè®®:", next_action(last, C, Base_P, zone_low_struct, upgrade, C_opt_score, R10, ATR10))
